const asyncHandler = require("express-async-handler");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const crypto = require("crypto");
const { OAuth2Client } = require("google-auth-library");

const ApiError = require("../utils/apiError");
const createToken = require("../utils/createToken");
const User = require("../models/userModel");
const sendEmail = require("../utils/sendEmail");

// Initialize Google OAuth2 client
const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// @desc    Register new user
// @route   POST /api/v1/auth/register
// @access  Public

exports.registerUser = asyncHandler(async (req, res, next) => {
  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø¥ÙŠÙ…ÙŠÙ„ ØºÙŠØ± Ù…Ø³ØªØ®Ø¯Ù… ÙƒØ­Ø³Ø§Ø¨ Google
  const existingUser = await User.findOne({ email: req.body.email.toLowerCase() });
  if (existingUser && existingUser.authProvider === "google") {
    return next(
      new ApiError(
        "Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³Ø¬Ù„ Ø¨Ø§Ù„ÙØ¹Ù„ Ø¹Ø¨Ø± Google. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ø¨Ø± Google",
        400
      )
    );
  }

  // âœ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ emailVerified = false
  const user = await User.create({
    name: req.body.name,
    email: req.body.email,
    password: req.body.password,
    emailVerified: false, // âœ… Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„ Ø­ØªÙ‰ Ø§Ù„Ø¢Ù†
    authProvider: "local", // ØªØ£ÙƒÙŠØ¯ Ø£Ù† Ù‡Ø°Ø§ Ø­Ø³Ø§Ø¨ Ù…Ø­Ù„ÙŠ
  });

  // âœ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ ØªØ­Ù‚Ù‚ Ù…Ù† 6 Ø£Ø±Ù‚Ø§Ù…
  const verificationCode = Math.floor(
    100000 + Math.random() * 900000
  ).toString();
  const hashedVerificationCode = crypto
    .createHash("sha256")
    .update(verificationCode)
    .digest("hex");

  // âœ… Ø­ÙØ¸ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
  user.emailVerificationCode = hashedVerificationCode;
  // âœ… Ø§Ù†ØªÙ‡Ø§Ø¡ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙƒÙˆØ¯ Ø¨Ø¹Ø¯ 10 Ø¯Ù‚Ø§Ø¦Ù‚
  user.emailVerificationExpires = Date.now() + 10 * 60 * 1000;

  await user.save();

  // âœ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¹Ø¨Ø± Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
  const message = `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${user.name},\n\nØ´ÙƒØ±Ø§Ù‹ Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ ÙÙŠ Filevo!\n\nÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ùˆ:\n${verificationCode}\n\nÙ‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ ØµØ§Ù„Ø­ Ù„Ù…Ø¯Ø© 10 Ø¯Ù‚Ø§Ø¦Ù‚.\n\nØ¥Ø°Ø§ Ù„Ù… ØªØ·Ù„Ø¨ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ØŒ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¬Ø§Ù‡Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.\n\nØ´ÙƒØ±Ø§Ù‹ Ù„ÙƒØŒ\nÙØ±ÙŠÙ‚ Filevo`;

  try {
    await sendEmail({
      email: user.email,
      subject: "ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ - Filevo",
      message,
    });
  } catch (err) {
    // âœ… ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ØŒ Ø­Ø°Ù Ø§Ù„ÙƒÙˆØ¯
    user.emailVerificationCode = undefined;
    user.emailVerificationExpires = undefined;
    await user.save();
    return next(new ApiError("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ", 500));
  }

  // âœ… Ø¥Ø±Ø¬Ø§Ø¹ Ø±Ø³Ø§Ù„Ø© Ù†Ø¬Ø§Ø­ Ø¨Ø¯ÙˆÙ† token (Ù„Ø£Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„)
  res.status(201).json({
    success: true,
    message:
      "ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù„Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚",
    userId: user._id,
    email: user.email,
  });
});

// @desc    Verify email verification code
// @route   POST /api/v1/auth/verifyEmail
// @access  Public
exports.verifyEmailCode = asyncHandler(async (req, res, next) => {
  const { email, verificationCode } = req.body;

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
  if (!email || !verificationCode) {
    return next(new ApiError("Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙˆÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ø·Ù„ÙˆØ¨Ø§Ù†", 400));
  }

  // âœ… ØªØ­ÙˆÙŠÙ„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ù„Ù‰ hash
  const hashedVerificationCode = crypto
    .createHash("sha256")
    .update(verificationCode)
    .digest("hex");

  // âœ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙˆÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
  const user = await User.findOne({
    email: email.toLowerCase(),
    emailVerificationCode: hashedVerificationCode,
    emailVerificationExpires: { $gt: Date.now() },
  });

  if (!user) {
    return next(new ApiError("ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ ØºÙŠØ± ØµØ­ÙŠØ­ Ø£Ùˆ Ù…Ù†ØªÙ‡ÙŠ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ©", 400));
  }

  // âœ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨
  user.emailVerified = true;
  user.emailVerificationCode = undefined;
  user.emailVerificationExpires = undefined;
  await user.save();

  // âœ… ØªÙˆÙ„ÙŠØ¯ token Ø¨Ø¹Ø¯ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨
  const token = createToken(user._id);

  // âœ… Ø­Ø°Ù ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
  delete user._doc.password;
  delete user._doc.emailVerificationCode;

  // âœ… ØªØ­ÙˆÙŠÙ„ profileImg Ø¥Ù„Ù‰ URL ÙƒØ§Ù…Ù„
  const { transformUserProfileImage } = require("../utils/profileImageHelper");
  const userWithProfileUrl = transformUserProfileImage(user, req);

  res.status(200).json({
    success: true,
    message: "ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­Ø³Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­",
    data: userWithProfileUrl,
    token,
  });
});

// @desc    Resend email verification code
// @route   POST /api/v1/auth/resendVerificationCode
// @access  Public
exports.resendVerificationCode = asyncHandler(async (req, res, next) => {
  const { email } = req.body;

  if (!email) {
    return next(new ApiError("Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø·Ù„ÙˆØ¨", 400));
  }

  // âœ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  const user = await User.findOne({ email: email.toLowerCase() });

  if (!user) {
    return next(new ApiError("Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯", 404));
  }

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„ Ø¨Ø§Ù„ÙØ¹Ù„
  if (user.emailVerified) {
    return next(new ApiError("Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…ÙØ¹Ù‘Ù„ Ø¨Ø§Ù„ÙØ¹Ù„", 400));
  }

  // âœ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙˆØ¯ ØªØ­Ù‚Ù‚ Ø¬Ø¯ÙŠØ¯
  const verificationCode = Math.floor(
    100000 + Math.random() * 900000
  ).toString();
  const hashedVerificationCode = crypto
    .createHash("sha256")
    .update(verificationCode)
    .digest("hex");

  // âœ… Ø­ÙØ¸ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø§Ù„Ø¬Ø¯ÙŠØ¯
  user.emailVerificationCode = hashedVerificationCode;
  user.emailVerificationExpires = Date.now() + 10 * 60 * 1000; // 10 Ø¯Ù‚Ø§Ø¦Ù‚
  await user.save();

  // âœ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¹Ø¨Ø± Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
  const message = `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${user.name},\n\nÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ùˆ:\n${verificationCode}\n\nÙ‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ ØµØ§Ù„Ø­ Ù„Ù…Ø¯Ø© 10 Ø¯Ù‚Ø§Ø¦Ù‚.\n\nØ¥Ø°Ø§ Ù„Ù… ØªØ·Ù„Ø¨ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ØŒ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¬Ø§Ù‡Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.\n\nØ´ÙƒØ±Ø§Ù‹ Ù„ÙƒØŒ\nÙØ±ÙŠÙ‚ Filevo`;

  try {
    await sendEmail({
      email: user.email,
      subject: "ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ - Filevo",
      message,
    });
  } catch (err) {
    // âœ… ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ØŒ Ø­Ø°Ù Ø§Ù„ÙƒÙˆØ¯
    user.emailVerificationCode = undefined;
    user.emailVerificationExpires = undefined;
    await user.save();
    return next(new ApiError("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ", 500));
  }

  res.status(200).json({
    success: true,
    message: "ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ",
  });
});

// @desc    Google Login/Signup
// @route   POST /api/v1/auth/google
// @access  Public
exports.googleLogin = asyncHandler(async (req, res, next) => {
  const { token } = req.body;

  if (!token) {
    return next(new ApiError("Google token is required", 400));
  }

  try {
    // Verify the Google token
    const ticket = await client.verifyIdToken({
      idToken: token,
      audience: process.env.GOOGLE_CLIENT_ID,
    });

    const payload = ticket.getPayload();
    const { email, name, picture, sub: googleId } = payload;

    // ðŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    let user = await User.findOne({ email: email.toLowerCase() });

    if (!user) {
      // Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯
      user = await User.create({
        name,
        email: email.toLowerCase(),
        googleId,
        profileImg: picture,
        authProvider: "google",
        emailVerified: true, // Google accounts are automatically verified
      });
    } else {
      // Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…ÙˆØ¬ÙˆØ¯ - ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Google Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
      if (user.authProvider !== "google") {
        return next(
          new ApiError(
            "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø¹Ø§Ø¯ÙŠ",
            400
          )
        );
      }

      // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Google
      user.googleId = googleId;
      if (picture && !user.profileImg) {
        user.profileImg = picture;
      }
      user.emailVerified = true;
      await user.save();
    }

    // ðŸ” Ø¥Ù†Ø´Ø§Ø¡ JWT
    const jwtToken = createToken(user._id);

    // âœ… Ø­Ø°Ù ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ù…Ù† Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
    delete user._doc.password;

    // âœ… ØªØ­ÙˆÙŠÙ„ profileImg Ø¥Ù„Ù‰ URL ÙƒØ§Ù…Ù„
    const { transformUserProfileImage } = require("../utils/profileImageHelper");
    const userWithProfileUrl = transformUserProfileImage(user, req);

    res.status(200).json({
      success: true,
      message: "ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­",
      data: userWithProfileUrl,
      token: jwtToken,
    });
  } catch (error) {
    console.error("Google login error:", error);
    return next(new ApiError("ÙØ´Ù„ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Google token", 401));
  }
});

// @desc    Login
// @route   GET /api/v1/auth/login
// @access  Public
exports.login = asyncHandler(async (req, res, next) => {
  // 1) check if password and email in the body (validation)
  // 2) check if user exist & check if password is correct
  const user = await User.findOne({ email: req.body.email });

  if (!user) {
    return next(
      new ApiError("Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©", 401)
    );
  }

  // âœ… Ù…Ù†Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ø°ÙŠÙ† Ø³Ø¬Ù„ÙˆØ§ Ø¹Ø¨Ø± Google Ù…Ù† Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ø§Ù„Ø¨Ø±ÙŠØ¯/Ø§Ù„Ø¨Ø§Ø³ÙˆØ±Ø¯
  if (user.authProvider === "google") {
    return next(
      new ApiError(
        "Ù‡Ø°Ø§ Ø§Ù„Ø­Ø³Ø§Ø¨ Ù…Ø³Ø¬Ù„ Ø¹Ø¨Ø± Google. ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ø¨Ø± Google",
        400
      )
    );
  }

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
  if (!user.password) {
    return next(
      new ApiError("Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©", 401)
    );
  }

  if (!(await bcrypt.compare(req.body.password, user.password))) {
    return next(
      new ApiError("Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø£Ùˆ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©", 401)
    );
  }

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…ÙØ¹Ù‘Ù„
  if (!user.emailVerified) {
    // âœ… Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„ØŒ Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
    const verificationCode = Math.floor(
      100000 + Math.random() * 900000
    ).toString();
    const hashedVerificationCode = crypto
      .createHash("sha256")
      .update(verificationCode)
      .digest("hex");

    // âœ… Ø­ÙØ¸ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    user.emailVerificationCode = hashedVerificationCode;
    user.emailVerificationExpires = Date.now() + 10 * 60 * 1000; // 10 Ø¯Ù‚Ø§Ø¦Ù‚
    await user.save();

    // âœ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¹Ø¨Ø± Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
    const message = `Ù…Ø±Ø­Ø¨Ø§Ù‹ ${user.name},\n\nØªÙ… Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¥Ù„Ù‰ Ø­Ø³Ø§Ø¨Ùƒ ÙÙŠ Filevo.\n\nÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ù‡Ùˆ:\n${verificationCode}\n\nÙ‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ ØµØ§Ù„Ø­ Ù„Ù…Ø¯Ø© 10 Ø¯Ù‚Ø§Ø¦Ù‚.\n\nÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ Ù„ØªÙØ¹ÙŠÙ„ Ø­Ø³Ø§Ø¨Ùƒ ÙˆØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„.\n\nØ¥Ø°Ø§ Ù„Ù… ØªØ·Ù„Ø¨ Ù‡Ø°Ø§ Ø§Ù„ÙƒÙˆØ¯ØŒ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ¬Ø§Ù‡Ù„ Ù‡Ø°Ù‡ Ø§Ù„Ø±Ø³Ø§Ù„Ø©.\n\nØ´ÙƒØ±Ø§Ù‹ Ù„ÙƒØŒ\nÙØ±ÙŠÙ‚ Filevo`;

    try {
      await sendEmail({
        email: user.email,
        subject: "ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ - Filevo",
        message,
      });
    } catch (err) {
      // âœ… ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ØŒ Ø­Ø°Ù Ø§Ù„ÙƒÙˆØ¯
      user.emailVerificationCode = undefined;
      user.emailVerificationExpires = undefined;
      await user.save();
      return next(new ApiError("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ", 500));
    }

    // âœ… Ø¥Ø±Ø¬Ø§Ø¹ Ø±Ø³Ø§Ù„Ø© ØªØ®Ø¨Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ù†Ù‡ ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯
    return res.status(403).json({
      success: false,
      message:
        "ÙŠØ±Ø¬Ù‰ ØªÙØ¹ÙŠÙ„ Ø­Ø³Ø§Ø¨Ùƒ Ø£ÙˆÙ„Ø§Ù‹. ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ù„Ù‰ Ø¨Ø±ÙŠØ¯Ùƒ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ",
      email: user.email,
      requiresVerification: true,
    });
  }

  // 3) generate token
  const token = createToken(user._id);

  // Delete password from response
  delete user._doc.password;

  // âœ… ØªØ­ÙˆÙŠÙ„ profileImg Ø¥Ù„Ù‰ URL ÙƒØ§Ù…Ù„
  const { transformUserProfileImage } = require("../utils/profileImageHelper");
  const userWithProfileUrl = transformUserProfileImage(user, req);

  // 4) send response to client side
  res.status(200).json({ data: userWithProfileUrl, token });
});

// @desc   make sure the user is logged in
exports.protect = asyncHandler(async (req, res, next) => {
  // 1) Check if token exist, if exist get
  let token;
  if (
    req.headers.authorization &&
    req.headers.authorization.startsWith("Bearer")
  ) {
    token = req.headers.authorization.split(" ")[1];
  }
  if (!token) {
    return next(
      new ApiError(
        "You are not login, Please login to get access this route",
        401
      )
    );
  }

  // 2) Verify token (no change happens, expired token)
  let decoded;
  try {
    decoded = jwt.verify(token, process.env.JWT_SECRET_KEY);
  } catch (err) {
    if (err.name === "TokenExpiredError") {
      return next(new ApiError("Token expired. Please login again", 401));
    }
    if (err.name === "JsonWebTokenError") {
      return next(new ApiError("Invalid token. Please login again", 401));
    }
    return next(new ApiError("Cannot identify user. Please re-login", 401));
  }

  // 3) Check if user exists
  const currentUser = await User.findById(decoded.userId);
  if (!currentUser) {
    return next(
      new ApiError(
        "The user that belong to this token does no longer exist",
        401
      )
    );
  }

  // 4) Check if user change his password after token created
  if (currentUser.passwordChangedAt) {
    const passChangedTimestamp = parseInt(
      currentUser.passwordChangedAt.getTime() / 1000,
      10
    );
    // Password changed after token created (Error)
    if (passChangedTimestamp > decoded.iat) {
      return next(
        new ApiError(
          "User recently changed his password. please login again..",
          401
        )
      );
    }
  }

  req.user = currentUser;
  next();
});

// @desc    Forgot password
// @route   POST /api/v1/auth/forgotPassword
// @access  Public
exports.forgotPassword = asyncHandler(async (req, res, next) => {
  // 1) Get user by email
  const user = await User.findOne({ email: req.body.email });
  if (!user) {
    return next(
      new ApiError(`There is no user with that email ${req.body.email}`, 404)
    );
  }
  // 2) If user exist, Generate hash reset random 6 digits and save it in db
  const resetCode = Math.floor(100000 + Math.random() * 900000).toString();
  const hashedResetCode = crypto
    .createHash("sha256")
    .update(resetCode)
    .digest("hex");

  // Save hashed password reset code into db
  user.passwordResetCode = hashedResetCode;
  // Add expiration time for password reset code (10 min)
  user.passwordResetExpires = Date.now() + 10 * 60 * 1000;
  user.passwordResetVerified = false;

  await user.save();

  // 3) Send the reset code via email
  const message = `Hi ${user.name},\n We received a request to reset the password on your Filevo Account. \n ${resetCode} \n Enter this code to complete the reset. \n Thanks for helping us keep your account secure.\n The Filevo Team`;
  try {
    await sendEmail({
      email: user.email,
      subject: "Your password reset code (valid for 10 min)",
      message,
    });
  } catch (err) {
    user.passwordResetCode = undefined;
    user.passwordResetExpires = undefined;
    user.passwordResetVerified = undefined;

    await user.save();
    return next(new ApiError("There is an error in sending email", 500));
  }

  res
    .status(200)
    .json({ status: "Success", message: "Reset code sent to email" });
});

// @desc    Verify password reset code
// @route   POST /api/v1/auth/verifyResetCode
// @access  Public
exports.verifyPassResetCode = asyncHandler(async (req, res, next) => {
  // 1) Get user based on reset code
  const hashedResetCode = crypto
    .createHash("sha256")
    .update(req.body.resetCode)
    .digest("hex");

  const user = await User.findOne({
    passwordResetCode: hashedResetCode,
    passwordResetExpires: { $gt: Date.now() },
  });
  if (!user) {
    return next(new ApiError("Reset code invalid or expired"));
  }

  // 2) Reset code valid
  user.passwordResetVerified = true;
  await user.save();

  res.status(200).json({
    status: "Success",
  });
});

// @desc    Reset password
// @route   POST /api/v1/auth/resetPassword
// @access  Public

// @desc    Reset password
exports.resetPassword = asyncHandler(async (req, res, next) => {
  const { newPassword, confirmPassword } = req.body;

  // 1) Get user based on email
  const user = await User.findOne({ email: req.body.email });
  if (!user) {
    return next(
      new ApiError(`There is no user with email ${req.body.email}`, 404)
    );
  }

  // 2) Check if reset code verified
  if (!user.passwordResetVerified) {
    return next(new ApiError("Reset code not verified", 400));
  }

  // 3) Check if newPassword and confirmPassword match
  if (!newPassword || !confirmPassword || newPassword !== confirmPassword) {
    return next(
      new ApiError("New password and confirm password do not match", 400)
    );
  }

  // âœ… 4) Save the new password (the hook will hash it automatically)
  user.password = newPassword;

  user.passwordResetCode = undefined;
  user.passwordResetExpires = undefined;
  user.passwordResetVerified = undefined;

  await user.save();

  // 5) Generate token and send response
  const token = createToken(user._id);
  res.status(200).json({ token });
});
